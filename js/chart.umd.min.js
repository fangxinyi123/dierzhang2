(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class Chart {
  constructor(canvas, config) {
    this.canvas = canvas;
    this.config = config;
    this.ctx = canvas.getContext('2d');
    this.init();
  }

  init() {
    this.drawChart();
  }

  drawChart() {
    const { type, data, options } = this.config;
    const ctx = this.ctx;
    const width = this.canvas.width;
    const height = this.canvas.height;
    
    // 清除画布
    ctx.clearRect(0, 0, width, height);
    
    // 绘制背景
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);
    
    // 根据类型绘制图表
    switch(type) {
      case 'line':
        this.drawLineChart(ctx, data, width, height);
        break;
      case 'bar':
        this.drawBarChart(ctx, data, width, height);
        break;
      case 'pie':
        this.drawPieChart(ctx, data, width, height);
        break;
      case 'scatter':
        this.drawScatterChart(ctx, data, width, height);
        break;
      case 'radar':
        this.drawRadarChart(ctx, data, width, height);
        break;
      default:
        this.drawBarChart(ctx, data, width, height);
    }
    
    // 绘制标题
    if (options && options.plugins && options.plugins.title) {
      ctx.fillStyle = '#333333';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(options.plugins.title.text || 'Chart', width / 2, 30);
    }
  }

  drawLineChart(ctx, data, width, height) {
    const margin = 50;
    const chartWidth = width - 2 * margin;
    const chartHeight = height - 2 * margin;
    
    // 绘制坐标轴
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, height - margin);
    ctx.lineTo(width - margin, height - margin);
    ctx.stroke();
    
    if (data.datasets && data.datasets.length > 0) {
      data.datasets.forEach((dataset, index) => {
        const color = dataset.borderColor || this.getColor(index);
        const points = dataset.data;
        
        if (points.length > 0) {
          const maxVal = Math.max(...points);
          const scale = chartHeight / maxVal;
          
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          points.forEach((value, i) => {
            const x = margin + (i * chartWidth) / (points.length - 1);
            const y = height - margin - (value * scale);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          
          ctx.stroke();
        }
      });
    }
  }

  drawBarChart(ctx, data, width, height) {
    const margin = 50;
    const chartWidth = width - 2 * margin;
    const chartHeight = height - 2 * margin;
    
    if (data.labels && data.datasets && data.datasets.length > 0) {
      const dataset = data.datasets[0];
      const values = dataset.data;
      const barCount = values.length;
      const barWidth = chartWidth / barCount * 0.8;
      const spacing = chartWidth / barCount * 0.2;
      
      const maxVal = Math.max(...values);
      const scale = chartHeight / maxVal;
      
      values.forEach((value, i) => {
        const x = margin + i * (barWidth + spacing);
        const barHeight = value * scale;
        const y = height - margin - barHeight;
        
        ctx.fillStyle = dataset.backgroundColor || this.getColor(i);
        ctx.fillRect(x, y, barWidth, barHeight);
      });
    }
  }

  drawPieChart(ctx, data, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    
    if (data.labels && data.datasets && data.datasets.length > 0) {
      const dataset = data.datasets[0];
      const values = dataset.data;
      const total = values.reduce((sum, val) => sum + val, 0);
      
      let startAngle = 0;
      
      values.forEach((value, i) => {
        const sliceAngle = (value / total) * 2 * Math.PI;
        
        ctx.fillStyle = dataset.backgroundColor[i] || this.getColor(i);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fill();
        
        startAngle += sliceAngle;
      });
    }
  }

  drawScatterChart(ctx, data, width, height) {
    const margin = 50;
    const chartWidth = width - 2 * margin;
    const chartHeight = height - 2 * margin;
    
    if (data.datasets && data.datasets.length > 0) {
      const dataset = data.datasets[0];
      const points = dataset.data;
      
      if (points.length > 0) {
        const xValues = points.map(p => p.x);
        const yValues = points.map(p => p.y);
        const maxX = Math.max(...xValues);
        const maxY = Math.max(...yValues);
        
        const xScale = chartWidth / maxX;
        const yScale = chartHeight / maxY;
        
        points.forEach(point => {
          const x = margin + point.x * xScale;
          const y = height - margin - point.y * yScale;
          
          ctx.fillStyle = dataset.backgroundColor || '#6a89cc';
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }
  }

  drawRadarChart(ctx, data, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    
    if (data.labels && data.datasets && data.datasets.length > 0) {
      const dataset = data.datasets[0];
      const values = dataset.data;
      const maxVal = Math.max(...values);
      const scale = radius / maxVal;
      
      const angleStep = (2 * Math.PI) / values.length;
      
      // 绘制雷达网
      ctx.strokeStyle = '#eeeeee';
      ctx.lineWidth = 1;
      
      for (let r = radius / 3; r <= radius; r += radius / 3) {
        ctx.beginPath();
        for (let i = 0; i <= values.length; i++) {
          const angle = i * angleStep;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      // 绘制数据线
      ctx.strokeStyle = dataset.borderColor || '#ff6b6b';
      ctx.fillStyle = dataset.backgroundColor || 'rgba(255, 107, 107, 0.2)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      values.forEach((value, i) => {
        const angle = i * angleStep;
        const r = value * scale;
        const x = centerX + r * Math.cos(angle);
        const y = centerY + r * Math.sin(angle);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }

  getColor(index) {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', 
                   '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'];
    return colors[index % colors.length];
  }

  destroy() {
    // 清除画布
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
}

var _default = Chart;
exports.default = _default;

},{}],2:[function(require,module,exports){
"use strict";

var _Chart = _interopRequireDefault(require("./core.controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 导出Chart类
window.Chart = _Chart.default;

},{"./core.controller":1}]},{},[2])(2)
});