(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Chart"] = factory();
	else
		root["Chart"] = factory();
})(window, function() {
var Chart = (function() {
  'use strict';
  
  function Chart(canvas, config) {
    if (!canvas) throw new Error('Canvas element is required');
    if (!config) throw new Error('Configuration is required');
    
    this.canvas = canvas;
    this.config = config;
    this.ctx = canvas.getContext('2d');
    
    this.render();
  }
  
  Chart.prototype.render = function() {
    var ctx = this.ctx;
    var config = this.config;
    var canvas = this.canvas;
    
    // 清除画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 绘制背景
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 根据图表类型绘制
    switch(config.type) {
      case 'bar':
        this.drawBarChart();
        break;
      case 'line':
        this.drawLineChart();
        break;
      case 'pie':
        this.drawPieChart();
        break;
      default:
        this.drawBarChart();
    }
  };
  
  Chart.prototype.drawBarChart = function() {
    var ctx = this.ctx;
    var config = this.config;
    var canvas = this.canvas;
    var data = config.data;
    
    if (!data || !data.labels || !data.datasets) return;
    
    var margin = 50;
    var chartWidth = canvas.width - 2 * margin;
    var chartHeight = canvas.height - 2 * margin;
    var barWidth = chartWidth / data.labels.length * 0.8;
    var spacing = chartWidth / data.labels.length * 0.2;
    
    // 绘制标题
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Bar Chart', canvas.width / 2, 30);
    
    // 绘制柱形图
    data.datasets.forEach(function(dataset, datasetIndex) {
      var maxVal = Math.max.apply(null, dataset.data);
      var scale = chartHeight / maxVal * 0.8;
      
      dataset.data.forEach(function(value, index) {
        var x = margin + index * (barWidth + spacing);
        var barHeight = value * scale;
        var y = margin + chartHeight - barHeight;
        
        ctx.fillStyle = dataset.backgroundColor || '#45b7d1';
        ctx.fillRect(x, y, barWidth, barHeight);
        
        // 绘制标签
        ctx.fillStyle = '#333333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(data.labels[index], x + barWidth/2, margin + chartHeight + 20);
        
        // 绘制数值
        ctx.fillText(value.toString(), x + barWidth/2, y - 5);
      });
    });
  };
  
  Chart.prototype.drawLineChart = function() {
    var ctx = this.ctx;
    var config = this.config;
    var canvas = this.canvas;
    var data = config.data;
    
    if (!data || !data.labels || !data.datasets) return;
    
    var margin = 50;
    var chartWidth = canvas.width - 2 * margin;
    var chartHeight = canvas.height - 2 * margin;
    
    // 绘制标题
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Line Chart', canvas.width / 2, 30);
    
    // 绘制折线图
    data.datasets.forEach(function(dataset, datasetIndex) {
      var maxVal = Math.max.apply(null, dataset.data);
      var scale = chartHeight / maxVal * 0.8;
      var pointSpacing = chartWidth / (data.labels.length - 1);
      
      ctx.strokeStyle = dataset.borderColor || '#ff6b6b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      dataset.data.forEach(function(value, index) {
        var x = margin + index * pointSpacing;
        var y = margin + chartHeight - value * scale;
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        
        // 绘制点
        ctx.fillStyle = dataset.borderColor || '#ff6b6b';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
      });
      
      ctx.stroke();
    });
  };
  
  Chart.prototype.drawPieChart = function() {
    var ctx = this.ctx;
    var config = this.config;
    var canvas = this.canvas;
    var data = config.data;
    
    if (!data || !data.labels || !data.datasets) return;
    
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    var radius = Math.min(canvas.width, canvas.height) / 3;
    
    // 绘制标题
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Pie Chart', canvas.width / 2, 30);
    
    // 绘制饼图
    var dataset = data.datasets[0];
    var total = dataset.data.reduce(function(a, b) { return a + b; }, 0);
    var startAngle = 0;
    
    dataset.data.forEach(function(value, index) {
      var sliceAngle = (value / total) * 2 * Math.PI;
      var endAngle = startAngle + sliceAngle;
      
      ctx.fillStyle = dataset.backgroundColor && dataset.backgroundColor[index] ? 
                     dataset.backgroundColor[index] : 
                     ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'][index % 5];
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fill();
      
      startAngle = endAngle;
    });
  };
  
  Chart.prototype.destroy = function() {
    // 简单的销毁方法
    this.canvas = null;
    this.config = null;
    this.ctx = null;
  };
  
  return Chart;
})();

return Chart;
});